---
title: 构造函数与析构函数
layout: post
categories: C++
tags: C++ 构造函数 析构函数
---
# <center>构造函数与析构函数<center/>  

<br/>
<br/>



-------------------------------  
>#  1.初始化和清理  

----------------------------------  
C++中OO思想也是来源于现实，是对现实事物的抽象模拟，具体来说，当我们常见对象的时候，这个对象应该有一个初始状态，当对象销毁之前应该销毁自己创建的一些数据。  
对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始化时，对其使用后果是未知的，同样的使用完一个变量，，没有及时清理，也会造成一定的安全问题。C++为了给我们提供这种问题的解决方案，构造函数和析构函数。这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。  
无论我们是否喜欢这种方式，对象的初始化和清理工作是编译器强制我们必须要做的事情，即使我们不提供初始化操作和清理操作，编译器也会给我们增加默认对的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。  
为什么初始化操作时自动调用而不是手动调用？既然是必然操作，那么自动调用会更好，如果靠我们自觉，那么就会存在遗漏初始化的情况出现。  
>#  2.构造函数  

----------------------------------  
构造函数主要作用在于创建时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。  
**构造函数语法：**  
- 构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数。  
- `ClassName(){}`

>#  3.析构函数  

----------------------------------  
析构函数主要用于对象销毁前系统自动调用，执行一些清理工作。  
**析构函数语法：**  
- 析构函数函数名是类名前面加"~"组成，没有返回值，不能有void，不能有参数，不能重载。  
- ~ClassName（）{}  


下面我举例说明构造函数与析构函数。  
```c++
#include <iostream>
using namespace std;

class  Person
{
public:
	Person()
	{
		cout << "构造函数调用" << endl;
	}
	~Person()
	{
		cout << "析构函数调用" << endl;
	}
};

void test()
{
	Person p1;
}

int main()
{
	test();
}
```
输出结果如下：   
![](https://i.imgur.com/scjw1sV.png)  
从输出结果我们可以看出，在创建对象时，构造函数调用。当对象销毁之前，又调用了析构函数。

>#  4.构造函数的分类及调用  

----------------------------------  

- 按参数类型：分为无参构造函数和有参构造函数  
- 按类型分类：分为普通构造函数和拷贝构造函数（复制构造函数）  


```c++
#include <iostream>
using namespace std;

class  Person
{
public:
	Person()//默认，无参构造函数
	{
		cout << "默认构造函数调用" << endl;
	}
	Person(int a)//有参构造函数调用
	{
		cout << "有参构造函数调用" << endl;
	}
	//拷贝构造函数
	Person(const Person& p)
	{
		m_age = p.m_age;
		cout << "拷贝构造函数调用" << endl;
	}
	~Person()
	{
		cout << "析构函数调用" << endl;
	}
	 long  m_age;
	 static int n_age;
	
};
static int n_age = 100;

void test()
{
	Person p1(1);//有参拷贝构造函数调用
	p1.m_age = 10;
	cout << "p1的年龄为：" << p1.m_age << endl;
	Person p2(p1);//拷贝构造函数调用
	cout << "p2的年龄为：" << p2.m_age << endl;
	Person(100);//匿名对象，当本行代码执行完毕就释放对象
	Person p3 = 100;//隐式类型转换，相当于调用了Person p7=Person(100)
	Person p4 = p3;//拷贝构造函数调用，相当于Person p4=Person(p3)

}

int main()
{
	test();
	return 0;
}
```
输出结果如下：  
![](https://i.imgur.com/p5CGt8x.png)   
这里，我们需要注意的是，析构函数和构造函数必须写在public下才可以调用。  
同时，对于无参构造函数（默认构造）、有参构造函数在创建对象时的调用应当注意。当我们我们没有定义构造函数时，系统会给我们提供一个空的默认构造函数，但是当我们定义了无参构造函数时，系统使用我们的构造函数。除此之外，当我们定义了一个有参构造函数，但是并没有提供无参构造函数时，在创建对象的时候必须使用有参构造。原因是，当我们声明一个有参构造函数之后，系统不再提供默认构造函数。  

<br/><br/><br/><br/><br/>

-------------------------------------
# <center>The End<center/>  
-------------------------------------